<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Hallway with Rooms, Candles, and Win</title>
<style>
  body { margin: 0; overflow: hidden; }
  #startButton {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 20px 40px;
    font-size: 24px;
    background: rgba(0,0,0,0.7);
    color: #fff;
    border: none;
    cursor: pointer;
    z-index: 10;
  }
  #winScreen {
    display: none;
    position: absolute;
    top:0; left:0; right:0; bottom:0;
    background: rgba(0,0,0,0.8);
    color: #fff;
    font-size: 36px;
    display: flex; align-items: center; justify-content: center;
    z-index: 20;
  }
</style>
</head>
<body>
<button id="startButton">Start</button>
<div id="winScreen">Congratulations! You Win!</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
<script>
let scene, camera, renderer;
let demon, cameraHolder;
const keys = {};
let candles = [];
let hasStarted = false;
let heldItem = null;
let walls = [];
let sign;
let win = false;
const numRoomsPerSide = 8;
const hallwayLength = 50;
const playerRadius = 0.2;
let gameRestarting = false;

const requiredCandles = 3;
let collectedCandles = 0;

// For swipe controls
let isDragging = false;
let previousTouch = { x: 0, y: 0 };
let yaw = 0;
let pitch = 0;

init();
animate();

document.getElementById('startButton').addEventListener('click', () => {
  document.getElementById('startButton').style.display = 'none';
  hasStarted = true;
});

function init() {
  scene = new THREE.Scene();

  // Camera setup
  cameraHolder = new THREE.Object3D();
  cameraHolder.position.set(0, 1.6, 0);
  scene.add(cameraHolder);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 200);
  camera.position.set(0, 0, 0);
  cameraHolder.add(camera);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Create the hallway
  const hallwayGeo = new THREE.BoxGeometry(4, 3, hallwayLength);
  const hallwayMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
  const hallway = new THREE.Mesh(hallwayGeo, hallwayMat);
  hallway.position.z = hallwayLength/2;
  scene.add(hallway);

  // Floor of hallway
  const floorGeo = new THREE.PlaneGeometry(4, hallwayLength);
  const floorMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI/2;
  floor.position.z = hallwayLength/2;
  scene.add(floor);

  // Side walls of hallway
  const wallGeo = new THREE.BoxGeometry(0.2, 3, hallwayLength);
  const wallMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
  // Walls array for collision detection
  walls = [];

  const leftWall = new THREE.Mesh(wallGeo, wallMat);
  leftWall.position.x = -2.2;
  leftWall.position.z = hallwayLength/2;
  scene.add(leftWall);
  walls.push(leftWall);

  const rightWall = new THREE.Mesh(wallGeo, wallMat);
  rightWall.position.x = 2.2;
  rightWall.position.z = hallwayLength/2;
  scene.add(rightWall);
  walls.push(rightWall);

  // Create 8 rooms on each side, with candles placed inside
  for(let i=0; i<numRoomsPerSide; i++) {
    const zPos = (i+1) * (hallwayLength / (numRoomsPerSide + 1));
    createRoom(-3, 0, zPos, true);
    createRoom(3, 0, zPos, false);
  }

  // Add the ghost-like demon inside the hallway
  const ghostGeo = new THREE.SphereGeometry(0.8, 16, 16);
  const ghostMat = new THREE.MeshStandardMaterial({ 
    color: 0xff0000, 
    transparent: true, 
    opacity: 0.6,
    emissive: 0xff0000,
    emissiveIntensity: 0.5
  });
  demon = new THREE.Mesh(ghostGeo, ghostMat);
  demon.position.set(0, 0.8, hallwayLength/2);
  scene.add(demon);

  // Glowing eyes
  const eyeGeo = new THREE.SphereGeometry(0.1, 8, 8);
  const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
  const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
  leftEye.position.set(0.7, 0.9, hallwayLength/2 - 0.2);
  scene.add(leftEye);
  const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
  rightEye.position.set(1.3, 0.9, hallwayLength/2 - 0.2);
  scene.add(rightEye);

  // Create the sign pointing to the "win" spot
  const signGeo = new THREE.PlaneGeometry(1, 0.5);
  const signMat = new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide });
  sign = new THREE.Mesh(signGeo, signMat);
  sign.position.set(0, 2, 10); // Position it towards the end of the hallway
  scene.add(sign);
  // Add text as a sprite or simple plane with text
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx.font = '40px Arial';
  ctx.fillStyle = 'white';
  ctx.fillText('Crouch to win here!', 0, 40);
  const texture = new THREE.CanvasTexture(canvas);
  sign.material.map = texture;
  sign.material.needsUpdate = true;

  // Lighting
  scene.add(new THREE.AmbientLight(0xffffff, 0.3));
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(5, 10, 5);
  scene.add(dirLight);

  // Handle window resize
  window.addEventListener('resize', () => {
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Keyboard controls
  window.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
  window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
  window.addEventListener('keydown', (e) => {
    if(e.key.toLowerCase() === 'e') {
      attemptPickup();
    }
  });

  // Swipe controls
  window.addEventListener('mousedown', startDrag);
  window.addEventListener('mouseup', endDrag);
  window.addEventListener('mousemove', onDrag);
  window.addEventListener('touchstart', startTouch);
  window.addEventListener('touchend', endTouch);
  window.addEventListener('touchmove', onTouchMove);
}

function createRoom(x, y, z, isLeftSide) {
  const roomSize = 3;
  const roomGeo = new THREE.BoxGeometry(roomSize, 3, roomSize);
  const roomMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
  const room = new THREE.Mesh(roomGeo, roomMat);
  room.position.set(x, y + 1.5, z);
  scene.add(room);

  // Walls for visual clarity
  const wallThickness = 0.2;
  const backWallGeo = new THREE.BoxGeometry(roomSize, 3, wallThickness);
  const frontWallGeo = backWallGeo;
  const sideWallGeo = new THREE.BoxGeometry(wallThickness, 3, roomSize);
  const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x777777 });

  const backWall = new THREE.Mesh(backWallGeo, wallMaterial);
  backWall.position.set(x, y + 1.5, z + roomSize/2);
  scene.add(backWall);
  const frontWall = new THREE.Mesh(frontWallGeo, wallMaterial);
  frontWall.position.set(x, y + 1.5, z - roomSize/2);
  scene.add(frontWall);
  const leftWall = new THREE.Mesh(sideWallGeo, wallMaterial);
  leftWall.position.set(x - roomSize/2, y + 1.5, z);
  scene.add(leftWall);
  const rightWall = new THREE.Mesh(sideWallGeo, wallMaterial);
  rightWall.position.set(x + roomSize/2, y + 1.5, z);
  scene.add(rightWall);

  // Spawn a candle near the entrance inside the room
  const candleGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
  const candleMat = new THREE.MeshStandardMaterial({ color: 0xffff00 });
  const candle = new THREE.Mesh(candleGeo, candleMat);
  // Place the candle near the edge of the room, closer to the hallway
  const offsetX = isLeftSide ? -1 : 1;
  candle.position.set(x + offsetX * (roomSize/2 - 0.2), y + 0.25, z);
  candle.userData = { isCandle: true, pickedUp: false };
  scene.add(candle);
  candles.push(candle);
}

function startDrag(e) { isDragging = true; previousTouch.x = e.clientX; previousTouch.y = e.clientY; }
function endDrag() { isDragging = false; }
function onDrag(e) {
  if(!isDragging) return;
  const deltaX = e.clientX - previousTouch.x;
  const deltaY = e.clientY - previousTouch.y;
  previousTouch.x = e.clientX;
  previousTouch.y = e.clientY;
  updateCameraRotation(deltaX, deltaY);
}

function startTouch(e) {
  if(e.touches.length === 1) {
    isDragging = true;
    previousTouch.x = e.touches[0].clientX;
    previousTouch.y = e.touches[0].clientY;
  }
}
function endTouch() { isDragging = false; }
function onTouchMove(e) {
  if(!isDragging || e.touches.length !== 1) return;
  const deltaX = e.touches[0].clientX - previousTouch.x;
  const deltaY = e.touches[0].clientY - previousTouch.y;
  previousTouch.x = e.touches[0].clientX;
  previousTouch.y = e.touches[0].clientY;
  updateCameraRotation(deltaX, deltaY);
}

function updateCameraRotation(deltaX, deltaY) {
  const sensitivity = 0.002;
  yaw -= deltaX * sensitivity;
  pitch -= deltaY * sensitivity;
  const maxPitch = Math.PI/2 - 0.01;
  const minPitch = -Math.PI/2 + 0.01;
  pitch = Math.max(minPitch, Math.min(maxPitch, pitch));
  cameraHolder.rotation.y = yaw;
  cameraHolder.rotation.x = pitch;
}

function animate() {
  requestAnimationFrame(animate);
  if (!hasStarted || win || gameRestarting) return;

  // Movement
  const speed = 0.05;
  const direction = new THREE.Vector3();

  if(keys['w']) { direction.z -= 1; }
  if(keys['s']) { direction.z += 1; }
  if(keys['a']) { direction.x -= 1; }
  if(keys['d']) { direction.x += 1; }

  direction.normalize();

  // Rotate movement by yaw
  const moveX = direction.x * Math.cos(yaw) - direction.z * Math.sin(yaw);
  const moveZ = direction.x * Math.sin(yaw) + direction.z * Math.cos(yaw);
  const newX = cameraHolder.position.x + moveX * speed;
  const newZ = cameraHolder.position.z + moveZ * speed;

  // Collision detection with walls
  const predictedPos = { x: newX, z: newZ };
  if(!checkCollision(predictedPos.x, predictedPos.z)) {
    cameraHolder.position.x = predictedPos.x;
    cameraHolder.position.z = predictedPos.z;
  }

  // Check if demon touches player
  const distToDemon = cameraHolder.position.distanceTo(demon.position);
  if(distToDemon < 1) {
    restartGame();
  }

  // Check win condition: if all candles collected and crouching at sign
  if(collectedCandles >= requiredCandles) {
    const distToSign = camera.position.distanceTo(sign.position);
    if(distToSign < 1 && keys['shift']) {
      showWinScreen();
    }
  }

  // Crouch
  if(keys['shift']) {
    cameraHolder.position.y = 1;
  } else {
    cameraHolder.position.y = 1.6;
  }

  // Animate demon (optional: move demon or keep static)
  // demon.position.x += Math.sin(Date.now()*0.001)*0.001; // Optional movement

  renderer.render(scene, camera);
}

function checkCollision(x, z) {
  // Check against walls
  for(let wall of walls) {
    const wx = wall.position.x;
    const wz = wall.position.z;
    const dx = Math.abs(x - wx);
    const dz = Math.abs(z - wz);
    const collisionX = dx < 1.2; // wall thickness + buffer
    const collisionZ = dz < 1.2;
    if(collisionX && collisionZ) return true;
  }
  // Check against room walls (optional, since walls are part of scene)
  // Could add more precise collision if needed
  return false;
}

function attemptPickup() {
  const pickRadius = 0.5;
  for(let candle of candles) {
    if(candle.userData.pickedUp) continue;
    const dist = camera.position.distanceTo(candle.position);
    if(dist < pickRadius) {
      candle.userData.pickedUp = true;
      cameraHolder.add(candle);
      candle.position.set(0, -0.2, -0.5);
      heldItem = candle;
      // Count candles
      collectedCandles = candles.filter(c => c.userData.pickedUp).length;
      break;
    }
  }
}

function restartGame() {
  // restart scene
  location.reload();
}

function showWinScreen() {
  document.getElementById('winScreen').style.display='flex';
  win = true;
}

// Additional code for user input and controls remains same
</script>
</body>
</html>
